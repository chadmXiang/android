ContextImpl.getSystemService  获取系统服务，返回保存SystemServiceRegistry 类里面的系统服务，对外提供的接口，类似ActivityManager，里面有一个IActivityManager，通过Binder和ActivityManagerService的通信，

ServiceManager.getService 是一个hide类，不支持app使用，针对之前的版本，可以使用反射来调用
https://stackoverflow.com/questions/41597003/how-to-get-a-service-from-servicemanager-in-android

从android P版本开始，对反射的使用有限制，对于预置三方应用可以通过添加白名单来解决限制
http://gityuan.com/2019/01/26/hidden_api/

Google的提交记录
https://android.googlesource.com/platform/art/+/b38988a227534ae17045dadedc24d2131d59b42d%5E1..b38988a227534ae17045dadedc24d2131d59b42d/


获取的服务都是下面注册的，本地服务或Java服务





Native层服务注册

1.servicemanager启动
文件路径：frameworks/native/cmds/servicemanager/

.rc文件调用servicemanager.c的main方法
1.调用bind.c的binder_open打开binder驱动
2.成为上下文管理者binder_become_context_manager
3.调用binder_loop进入无限循环，处理client端发来的请求
4.注册服务和死亡通知

在binder_open方法中
1.通过系统调用open("/deve/binder",O_RDWR|O_CLOEXEC)
2.通过系统调用ioctl获取binder版本信息
3.通过系统调用mmap内存映射

在binder_become_context_manager里面
1.通过ioctl，传递BINDER_SET_CONTEXT_MGR指令，成为上下文管理者，整个系统只有一个

servicemanager最核心的2个功能是查询和注册服务
a)注册服务：记录服务名和handle信息
b)查询服务：根据服务名查相应的handle信息

每一个服务用svcinfo结构体来表示：
struct svcinfo { 
struct svcinfo *next; 
uint32_t handle; //服务的handle值 
struct binder_death death; 
int allow_isolated; 
size_t len; //名字长度 
uint16_t name[0]; //服务名 
};

servicemanager启动，打开binder驱动，成为Context manager，句柄为0

3.native服务注册过程

3.1服务在注册的时候，会调用
defaultServiceManager()->addService(String16("media.player"), new MediaPlayerService());


3.2 在defaultServiceManager方法里面
interface_cast<IServiceManager>(ProcessState::self()->getContextObject(nullptr));
ProcessState::self()会创建ProcessState对象，然后根据传入的handle为0(代表service manager),返回BpBinder对象，进行interface_cast转换，最终返回BpServiceManager,然后调用其addService方法

3.3 在BpServiceManager.addService方法里面
status_t err = remote()->transact(ADD_SERVICE_TRANSACTION, data, &reply);
其中remote()对象是BpBinder,最终会调用到IPCThreadState的transact方法
remote()方法定义在BpRefBase,返回IBinder对象


Java层服务注册
ZygoteInit里面，forkSystemServer方法通过反射调用SystemServer的main方法

SystemServer.run

先创建SystemServiceManager，管理所有SystemService的创建、启动以及生命周期事件处理

startBootstrapServivce 启动android系统投入运行所需的关键服务最小集

startCoreServices  启动系统投入运行所需的关键服务最小集以外的关键服务

startOtherServices  启动其它服务

LocalServices里面保存的服务，使用只能在同一个进程里面调用，不允许跨进程调用，注册的对象保存在一个ArrayMap对象sLocalServiceObjects ，是Hide，仅android系统内部

ServiceManager 保存着Binder对象的服务注册，内部保存着一个ServiceManagerNative，注册的服务通过Binder调用native层的servicemanager的addService方法，保存在svclist 链表里面

启动过程中，通过2种不同的方式来注册系统服务，最终都是通过binder调用向native层的servicemanager注册

ServiceManager的addService()   直接通过binder调用向native层的servicemanager注册
SystemServiceManager的startService()  先走SystemService的生命周期方法，然后再通过publicBinderService向native层的servicemanager注册

getIServiceManager
ServiceManagerNative.asInterface(Binder.allowBlocking(BinderInteral.getContextObject()))

static jobject android_os_BinderInternal_getContextObject(JNIEnv* env, jobject clazz)
 {

     sp<IBinder> b = ProcessState::self()->getContextObject(NULL);

     return javaObjectForIBinder(env, b);

 }

然后调用ProcessState::getStrongProxyForHandle  ,返回BpBinder(0)

BinderProxy内部有一个nativeData,是一个BinderProxyNativeData，保存着sp<IBinder> mObject; 是一个BpBinder对象，传入的句柄是0,代理着native层的servicemanager

mRemote为BinderProxy对象，该BinderProxy对象对应于BpBinder(0)，其作为binder代理端，指向native层大管家service Manager。


抽象类SystemService代表一个运行在system_server进程里面的服务，生命周期方法有
onStart() 启动服务
publicBinderService 对象提供接口，system_server里面的其它服务可以访问service内部方法
onBootPhase 会被调用多次，表示被启动的各个阶段
PHASE_WAIT_FOR_DEFAULT_DISPLAY = 100;
PHASE_LOCK_SETTINGS_READY = 480;
PHASE_SYSTEM_SERVICES_READY = 500;
PHASE_DEVICE_SPECIFIC_SERVICES_READY = 520;
PHASE_ACTIVITY_MANAGER_READY = 550;
PHASE_THIRD_PARTY_APPS_CAN_START = 600;
PHASE_BOOT_COMPLETED = 1000;


frameworks/native/cmds/servicemanager/
http://gityuan.com/2016/10/01/system_service_common/


非系统服务

startForeground 启动前台服务，

每个前台服务必须显示优先级为PRIORITY_LOW或更高状态栏通知

在API 28或更高的版本上，需要申明一个权限<uses-permission android:name="android.permission.FOREGROUND_SERVICE"/>

startService 允许服务无限期运行

bindService 一个绑定的服务是CS结构中的service端，允许组件bind到服务上后，与服务进程IPC通信。
一个绑定服务一般只在服务其它组件的时候才存活，不会一直在后台运行，应该显式的调用stopSelf或stopService来停止服务，
在服务端，需要实现onBind方法，返回一个IBinder对象,客户端用此对象来与服务端进行交互
在客户端，需要实现一个ServiceConnection回调，在bindService的时候作为参数传入，客户端在回调方法里面获取到服务端返回的IBinder对象
如果想和远程服务(remote service)通信，可以使用Messenger来返回一个IBinder对象，利用Handler消息机制

AIDL
定义了在IPC过程中，客户端和服务端进行交互的接口，适用于多个Client与Service进行交互的场景，在Service端进行多线程处理，如果不需要进行多线程IPC，可以使用bindService来实现

通过AIDL创建服务有3步：
创建.aidl文件
实现接口功能，android SDK工具生成了一个抽象的Stub实现，必须继承然后实现Stub里面的方法
向Client端提供访问接口，实现onBinder方法，返回一个Stub对象

在ActiveServices的final SparseArray<ServiceMap> mServiceMap 对象里面，保存着所有非系统服务，key为user id,value为ServiceMap
ServiceMap保存着单个用户的所有服务信息

ContextImpl.startService --> ContextImpl.startServiceCommon --> ActivityManagerService.startService --> ActiveServices.startServiceLocked --》1.ActiveServices.retrieveServiceLocked 创建一个新的ServiceRecord，添加到ServiceMap里面 
2.--> ActiveService.startServiceInnerLocked --> bringUpServiceLocked --> realStartServiceLocked -->

1.ActivityThread.scheduleCreateService --> handleCreateService 通过工厂方法创建一个Service实例，然后调用其attach,onCreate后，通过binder调用AMS的serviceDoneExecuting --> ActiveServices.serviceDoneExecuting 判断启动类型

2.ActivityThread.sendServiceArgsLocked --> ActivityThread.scheduleServiceArgs --> ActivityThread.handleServiceArgs 在这个方法里面，调用onStartCommand方法


ContextImpl.bindService --> ContextImpl.bindServiceCommon --> ActivityManagerService.bindIsolatedService --> ActiveServices.bindServiceLocked
--> 
1.retrieveServiceLocked 创建一个新的ServiceRecord，添加到ServiceMap里面

2.当需要判断一个组件是否能启动，会一个权限判断的Intent,在callback里面异步调用bringUpServiceLocked，绑定但不启动服务，和startService的一个主要差异点，在bringUpServiceLocked方法里面，会判断是否是isolated的，由于传入的BIND_AUTO_CREATE，isolated为false，走和startService一样的流程realStartServiceLocked，注意：此时App的进程可能还没有创建，调用startProcessLocked创建应用进程，

3.继续对启动flags进行判断处理，处理一些bind相关的，

4.对于BIND_AUTO_CREATE类型，再次调用bringUpServiceLocked，如果成功，则返回，失败则调用connected重新bind

https://developer.android.google.cn/guide
http://gityuan.com/2015/11/21/binder-framework/
http://gityuan.com/2015/11/15/binder-get-service/


接收方注册
Context
	registerReceiver
	
ContextImpl
	registerReceiver
		registerReceiverInternal
			ActivityManager.getService().registerReceiver(

ActivityManagerService			
	registerReceiver	
		--queue.enqueueParallelBroadcastLocked(r);
		  queue.scheduleBroadcastsLocked();
			
BroadcastQueue                    
				

发送方
BroadcastReceiver
Context	
	sendBroadcast

ContextImpl
	ActivityManager.getService().broadcastIntent
	
ActivityManagerService
	broadcastIntent
	--broadcastIntentLocked
		--queue.enqueueParallelBroadcastLocked(r);
          queue.scheduleBroadcastsLocked();

BroadcastQueue
	scheduleBroadcastsLocked
		processNextBroadcast
			--processNextBroadcastLocked
				--processCurBroadcastLocked
		
ActivityTrhead
	scheduleReceiver
		--handleReceiver
			--handleReceiver
				--receiver.onReceive





